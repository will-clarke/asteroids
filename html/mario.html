<html>
    <body>
        <pre>

DRAGGING cube around

import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (on)
import Json.Decode as Decode
import Mouse exposing (Position)



main =
  Html.program
    { init = init
    , view = view
    , update = update
    , subscriptions = subscriptions
    }


-- MODEL


type alias Model =
    { position : Position
    , drag : Maybe Drag
    }


type alias Drag =
    { start : Position
    , current : Position
    }


init : ( Model, Cmd Msg )
init =
  ( Model (Position 200 200) Nothing, Cmd.none )



-- UPDATE


type Msg
    = DragStart Position
    | DragAt Position
    | DragEnd Position


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
  ( updateHelp msg model, Cmd.none )


updateHelp : Msg -> Model -> Model
updateHelp msg ({position, drag} as model) =
  case msg of
    DragStart xy ->
      Model position (Just (Drag xy xy))

    DragAt xy ->
      Model position (Maybe.map (\{start} -> Drag start xy) drag)

    DragEnd _ ->
      Model (getPosition model) Nothing



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
  case model.drag of
    Nothing ->
      Sub.none

    Just _ ->
      Sub.batch [ Mouse.moves DragAt, Mouse.ups DragEnd ]



-- VIEW


(=>) = (,)


view : Model -> Html Msg
view model =
  let
    realPosition =
      getPosition model
  in
    div
      [ onMouseDown
      , style
          [ "background-color" => "#3C8D2F"
          , "cursor" => "move"

          , "width" => "100px"
          , "height" => "100px"
          , "border-radius" => "4px"
          , "position" => "absolute"
          , "left" => px realPosition.x
          , "top" => px realPosition.y

          , "color" => "white"
          , "display" => "flex"
          , "align-items" => "center"
          , "justify-content" => "center"
          ]
      ]
      [ text "Drag Me!"
      ]


px : Int -> String
px number =
  toString number ++ "px"


getPosition : Model -> Position
getPosition {position, drag} =
  case drag of
    Nothing ->
      position

    Just {start,current} ->
      Position
        (position.x + current.x - start.x)
        (position.y + current.y - start.y)


onMouseDown : Attribute Msg
onMouseDown =
on "mousedown" (Decode.map DragStart Mouse.position)


======================================
======================================
======================================
======================================
======================================
======================================

MARIO

module Main exposing (..)

import AnimationFrame exposing (..)
import Collage exposing (..)
import Color exposing (..)
import Element exposing (..)
import Html exposing (Html)
import Keyboard
import Task
import Time exposing (Time)
import Window


-- MODEL


type alias Model =
    { x : Float
    , y : Float
    , vx : Float
    , vy : Float
    , dir : Direction
    , windowSize : Window.Size
    , keys : Keys
    }


type Direction
    = Left
    | Right


type alias Keys =
    { x : Int, y : Int }


mario : Model
mario =
    { x = 0
    , y = 0
    , vx = 0
    , vy = 0
    , dir = Right
    , windowSize = { width = 0, height = 0 }
    , keys = { x = 0, y = 0 }
    }



-- UPDATE


applyKey : Int -> Keyboard.KeyCode -> Keys -> Keys
applyKey scale key keys =
    case key of
        37 ->
            { keys | x = -scale }

        38 ->
            { keys | y = scale }

        39 ->
            { keys | x = scale }

        40 ->
            { keys | y = -scale }

        _ ->
            keys


step : Msg -> Model -> ( Model, Cmd Msg )
step msg mario =
    case msg of
        Frame dt ->
            ( mario
                |> gravity (dt / 10)
                |> jump mario.keys
                |> walk mario.keys
                |> physics (dt / 10)
            , Cmd.none
            )

        KeyDown key ->
            ( { mario
                | keys = applyKey 1 key mario.keys
              }
            , Cmd.none
            )

        KeyUp key ->
            ( { mario | keys = applyKey 0 key mario.keys }
            , Cmd.none
            )

        WindowSize size ->
            ( { mario | windowSize = size }
            , Cmd.none
            )


jump : Keys -> Model -> Model
jump keys mario =
    if keys.y > 0 && mario.vy == 0 then
        { mario | vy = 6.0 }
    else
        mario


gravity : Float -> Model -> Model
gravity dt mario =
    { mario
        | vy =
            if mario.y > 0 then
                mario.vy - dt / 4
            else
                0
    }


physics : Float -> Model -> Model
physics dt mario =
    { mario
        | x = mario.x + dt * mario.vx
        , y = max 0 (mario.y + dt * mario.vy)
    }


walk : Keys -> Model -> Model
walk keys mario =
    { mario
        | vx = toFloat keys.x
        , dir =
            if keys.x < 0 then
                Left
            else if keys.x > 0 then
                Right
            else
                mario.dir
    }



-- DISPLAY


display : Model -> Html Msg
display model =
    let
        ( w, h ) =
            ( toFloat model.windowSize.width
            , toFloat model.windowSize.height
            )

        verb =
            if model.y > 0 then
                "jump"
            else if model.vx /= 0 then
                "walk"
            else
                "stand"

        dir =
            case model.dir of
                Left ->
                    "left"

                Right ->
                    "right"

        src =
            "imgs/mario/" ++ verb ++ "/" ++ dir ++ ".gif"

        marioImage =
            image 35 35 src

        groundY =
            62 - h / 2
    in
        collage
            model.windowSize.width
            model.windowSize.height
            [ rect w h
                |> filled (rgb 174 238 238)
            , rect w 50
                |> filled (rgb 74 167 43)
                |> move ( 0, 24 - h / 2 )
            , marioImage
                |> toForm
                |> move ( model.x, model.y + groundY )
            ]
            |> Element.toHtml



-- PROGRAM


type Msg
    = Frame Time
    | KeyDown Keyboard.KeyCode
    | KeyUp Keyboard.KeyCode
    | WindowSize Window.Size


main : Program Never Model Msg
main =
    Html.program
        { init = ( mario, Window.size |> Task.perform WindowSize )
        , update = step
        , view = display
        , subscriptions =
            \model ->
                Sub.batch
                    [ Keyboard.downs KeyDown
                    , Keyboard.ups KeyUp
                    , AnimationFrame.diffs Frame
                    , Window.resizes WindowSize
                    ]
        }


==============================
==============================
==============================
==============================
==============================
==============================
==============================
==============================
==============================
FIRST PERSON


-- Try adding the ability to crouch or to land on top of the crate.

import Http (..)
import Keyboard
import Math.Vector2 (Vec2)
import Math.Vector3 (..)
import Math.Vector3 as V3
import Math.Matrix4 (..)
import Graphics.WebGL (..)
import Window

type Person = { position:Vec3, velocity:Vec3 }

eyeLevel : Float
eyeLevel = 2

defaultPerson : Person
defaultPerson =
  { position = vec3 0 eyeLevel -10, velocity = vec3 0 0 0 }

walk : { x:Int, y:Int } -> Person -> Person
walk directions person =
  if getY person.position > eyeLevel then person else
    let vx = toFloat -directions.x
        vz = toFloat  directions.y
    in
        { person | velocity <- vec3 vx (getY person.velocity) vz }

jump : Bool -> Person -> Person
jump isJumping person =
  if not isJumping || getY person.position > eyeLevel then person else
    let (vx,_,vz) = toTuple person.velocity
    in
        { person | velocity <- vec3 vx 2 vz }

physics : Float -> Person -> Person
physics dt person =
    let position = person.position `add` V3.scale dt person.velocity
        (x,y,z) = toTuple position
    in
        { person | position <- if y < eyeLevel then vec3 x eyeLevel z else position }

gravity : Float -> Person -> Person
gravity dt person =
  if getY person.position <= eyeLevel then person else
    let v = toRecord person.velocity
    in
        { person | velocity <- vec3 v.x (v.y - 2 * dt) v.z }

step : Inputs -> Person -> Person
step (isJumping, directions, dt) person =
    physics dt (gravity dt (jump isJumping (walk directions person)))

-- View
view : (Int,Int) -> Person -> Mat4
view (w,h) person =
    mul (makePerspective 45 (toFloat w / toFloat h) 0.01 100)
        (makeLookAt person.position (person.position `add` k) j)

-- Putting it together
main : Signal Element
main =
  let person = foldp step defaultPerson inputs
      entities = world <~ loadTexture "/texture/woodCrate.jpg"
                        ~ lift2 view Window.dimensions person
  in  lift2 scene Window.dimensions entities

msg = "Walk around with a first person perspective.\n" ++
      "Arrows keys to move, space bar to jump."

scene : (Int,Int) -> [Entity] -> Element
scene (w,h) entities =
    layers [ webgl (w,h) entities
           , plainText msg
               |> container w 100 (midLeftAt (absolute 40) (relative 0.5))
           ]

type Inputs = (Bool, {x:Int, y:Int}, Float)

inputs : Signal Inputs
inputs =
  let dt = lift (\t -> t/500) (fps 25)
  in  sampleOn dt <| (,,) <~ Keyboard.space ~ Keyboard.arrows ~ dt

world : Response Texture -> Mat4 -> [Entity]
world response view =
  case response of
    Waiting     -> []
    Failure _ _ -> []
    Success tex -> [entity vertexShader fragmentShader crate { crate=tex, view=view }]

-- Define the mesh for a crate
type Vertex = { position:Vec3, coord:Vec3 }

crate : [Triangle Vertex]
crate = concatMap rotatedFace [ (0,0), (90,0), (180,0), (270,0), (0,90), (0,-90) ]

rotatedFace : (Float,Float) -> [Triangle Vertex]
rotatedFace (angleXZ,angleYZ) =
  let x = makeRotate (degrees angleXZ) j
      y = makeRotate (degrees angleYZ) i
      t = x `mul` y
  in
      map (mapTriangle (\v -> {v | position <- transform t v.position })) face

face : [Triangle Vertex]
face =
  let topLeft     = Vertex (vec3 -1  1 1) (vec3 0 1 0)
      topRight    = Vertex (vec3  1  1 1) (vec3 1 1 0)
      bottomLeft  = Vertex (vec3 -1 -1 1) (vec3 0 0 0)
      bottomRight = Vertex (vec3  1 -1 1) (vec3 1 0 0)
  in
      [ (topLeft,topRight,bottomLeft), (bottomLeft,topRight,bottomRight) ]

-- Shaders
vertexShader : Shader { position:Vec3, coord:Vec3 } { u | view:Mat4 } { vcoord:Vec2 }
vertexShader = [glsl|

attribute vec3 position;
attribute vec3 coord;
uniform mat4 view;
varying vec2 vcoord;

void main () {
  gl_Position = view * vec4(position, 1.0);
  vcoord = coord.xy;
}

|]

fragmentShader : Shader {} { u | crate:Texture } { vcoord:Vec2 }
fragmentShader = [glsl|

precision mediump float;
uniform sampler2D crate;
varying vec2 vcoord;

void main () {
  gl_FragColor = texture2D(crate, vcoord);
}

|]

        </pre>
    </body>
</html>
